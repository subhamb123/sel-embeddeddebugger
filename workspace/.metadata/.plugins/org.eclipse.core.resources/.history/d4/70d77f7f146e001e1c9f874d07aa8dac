# Set the base address and size of the stack memory region
set STACK_BASE_ADDRESS 0x0  ;
set STACK_SIZE 0x2000       ;

# Read stack memory from the board
proc readStackMemory {baseAddress size} {
    # Use the mrd command to read memory in XSCT
    set stackData [mrd $baseAddress $size]
    return $stackData
}

# Read stack memory data
set stackMemoryData [readStackMemory $STACK_BASE_ADDRESS $STACK_SIZE]

# Print the stack memory data
#puts "Stack Memory Data:"
#puts $stackMemoryData

# Make a dictionary to map functions to addresses
set symbolTable [dict create 0000000000000d00 main 0000000000000d50 valid 0000000000000d74 invalid]

proc decodeCallStack {stackAddresses symbolTable} {
    foreach row $stackAddresses {
    	# Remove spaces and other characters from the beginning of the string
		set cleanedString [string trimleft $row " 0:"]

		# Extract the hexadecimal value
		set hexValue [string range $cleanedString 0 end]
		
		if {[dict exists $symbolTable $address]} {
		    set functionName [dict get $symbolTable $address]
		} else {
		    set functionName "UnknownFunction"
		}

        #set functionName [dict get $symbolTable $hexValue "UnknownFunction"]
        puts "Address: $address -> Function: $functionName"
    }
}
# Split the stack memory data into individual addresses
#set stackAddresses [split $stackMemoryData "\n"]

# Decode and display the call stack
decodeCallStack $stackAddresses $symbolTable