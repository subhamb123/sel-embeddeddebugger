# Set the base address and size of the stack memory region
set STACK_BASE_ADDRESS 0x0  ;
set STACK_SIZE 0x2000       ;

# Read stack memory from the board
proc readStackMemory {baseAddress size} {
    # Use the mrd command to read memory in XSCT
    set stackData [mrd $baseAddress $size]
    return $stackData
}

# Read stack memory data
set stackMemoryData [readStackMemory $STACK_BASE_ADDRESS $STACK_SIZE]

# Print the stack memory data
#puts "Stack Memory Data:"
#puts $stackMemoryData

# Make a dictionary to map functions to addresses
set symbolTable [dict create 00000d00 main 00000d50 valid 00000d74 invalid]

proc decodeCallStack {stackAddresses symbolTable} {
    foreach row $stackAddresses {
    	# Remove spaces and other characters from the beginning of the string
		set cleanedString [string trimleft $row " :"]

		# Extract the hexadecimal value
		set hexValue [string range $cleanedString 0 end]
				
		if {[string match "*:" $row]} {
		    set str [string range $str 0 end-6]
		}
		puts $str
				
		
		if {[dict exists $symbolTable $hexValue]} {
		    set functionName [dict get $symbolTable $hexValue]
		} else {
		    set functionName "UnknownFunction"
		}

        #set functionName [dict get $symbolTable $hexValue "UnknownFunction"]
        
        #puts "Address: $hexValue -> Function: $functionName"
        
    }
}
# Split the stack memory data into individual addresses
#set stackAddresses [split $stackMemoryData "\n"]

# Decode and display the call stack
decodeCallStack $stackAddresses $symbolTable